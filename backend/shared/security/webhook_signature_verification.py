"""
Unified webhook signature verification for all services.
Handles signature verification for Slack, Shopify, and other webhook sources.
"""

import hmac
import hashlib
import base64
import logging
from enum import Enum
from typing import Optional

logger = logging.getLogger(__name__)

class SlackSignatureError(Exception):
    """Base exception for Slack signature verification errors."""
    pass

class MissingSlackSignatureError(SlackSignatureError):
    """Raised when x-slack-signature header is missing."""
    pass

class MissingSlackTimestampError(SlackSignatureError):
    """Raised when x-slack-request-timestamp header is missing."""
    pass

class MissingSlackAppIdError(SlackSignatureError):
    """Raised when api_app_id is missing from request."""
    pass

class MissingSlackRequestBodyError(SlackSignatureError):
    """Raised when raw request body is missing."""
    pass

class InvalidSlackSignatureError(SlackSignatureError):
    """Raised when signature verification fails."""
    pass

class MissingSlackSigningSecretError(SlackSignatureError):
    """Raised when signing secret cannot be found for the app_id."""
    pass


def is_valid_webhook_signature(
    received_signature: str,
    expected_signature: str,
) -> bool:
    """
    Generic signature comparison supporting multiple formats.
    
    Args:
        received_signature: The signature to verify
        expected_signature: The expected signature (generated by service)
        
    Returns:
        True if signature is valid
        
    Raises:
        InvalidSlackSignatureError: If signatures don't match
    """

    try:
        
        is_valid = hmac.compare_digest(received_signature, expected_signature)
        
        if not is_valid:
            raise InvalidSlackSignatureError("Signature verification failed - signatures do not match")
        
        return True
        
    except InvalidSlackSignatureError:
        raise
    except Exception as e:
        raise InvalidSlackSignatureError(f"Signature verification failed: {e}")


def extract_shopify_webhook_signature(headers: dict) -> Optional[str]:
    """
    Extract signature from request headers based on source.
    
    Args:
        headers: Request headers dict (case-insensitive)
        
    Returns:
        Signature, or None if missing
    """
    # Normalize headers to lowercase for case-insensitive lookup
    normalized_headers = {k.lower(): v for k, v in headers.items()}
        
    signature = normalized_headers.get("x-shopify-hmac-sha256")
    return signature


def extract_slack_webhook_signature(headers: dict, signing_secret: str, raw_request_body: bytes, app_id: str) -> str:
    """Extract and calculate the expected signature from Slack webhook data."""
    received_signature = headers.get("x-slack-signature")
    timestamp = headers.get("x-slack-request-timestamp")
    
    if not received_signature:
        raise MissingSlackSignatureError("x-slack-signature header is required for Slack signature verification")
    
    if not timestamp:
        raise MissingSlackTimestampError("x-slack-request-timestamp header is required for Slack signature verification")
    
    if not raw_request_body:
        raise MissingSlackRequestBodyError("Raw request body is required for Slack signature verification")
    
    if not app_id:
        raise MissingSlackAppIdError("api_app_id is required for Slack signature verification")
    
    request_body_str = raw_request_body.decode('utf-8')
    
    # Create the signature string that Slack uses
    sig_basestring = f"v0:{timestamp}:{request_body_str}"
    
    expected_signature = "v0=" + hmac.new(
        signing_secret.encode('utf-8'),
        sig_basestring.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    return expected_signature